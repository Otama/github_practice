#+OPTIONS: ^:{}
#+OPTIONS: toc:nil

#+LaTeX_CLASS_OPTIONS: [a4paper,twoside,twocolumn]
#+LaTeX_HEADER: \usepackage[normalem]{ulem}

#+TITLE: GitHub入門
#+AUTHOR: 産業技術大学院大学\\ 中鉢 欣秀
#+DATE: 2016-08-14

#+BEGIN_abstract
これはGitの初心者が，基礎的なGitコマンドの利用方法から，
GitHubフローに基づく協同開発の方法までを学ぶ演習である．

事前に gitコマンドが利用できる環境を用意しておくこと．
またCUI端末でのshellによる基本的な操作を知っていると
スムーズに演習ができる．

第1章はGit初心者（初めてさわる者）を対象に基礎を学ぶ．
第2章は個人によるGitHubの初歩的な使い方を取り扱う．
第3章ではチームによるGitHubの使い方を知ろう．

#+END_abstract

* Git入門
** Gitの設定
*** Gitコマンドの実行確認
- 端末を操作してGitコマンドを起動してみよう．
- 次のとおり操作することでGitのバージョン番号が確認できる．

#+BEGIN_SRC bash
git --version
#+END_SRC

*** 名前とメールアドレスの登録
- 名前とメールアドレスを登録しておく
- 次のコマンドの$NAMEと$EMAILを各自の名前とメールアドレスに置き換えて実行せよ
  - 名前はローマ字で設定すること

#+BEGIN_SRC bash
git config --global user.name $NAME
git config --global user.email $EMAIL
#+END_SRC

*** その他の設定
- 次のとおり，設定を行っておく
  - 1行目：色付きで表示を見やすく
  - 2行目：pushする方法（詳細省略）

#+BEGIN_SRC bash
git config --global color.ui auto
git config --global push.default simple
#+END_SRC

*** 設定の確認方法
- ここまでの設定を確認する

#+BEGIN_SRC bash
git config -l
#+END_SRC

** Gitのリポジトリ
*** プロジェクト用のディレクトリ
- リポジトリとはプロジェクトでソースコードなどを
  配置するディレクトリ
- Gitのリポジトリバージョン管理ができるようになる
- GitHubと連携させることで共同作業ができる

*** Gitリポジトリを利用するには
- リポジトリを利用する方法には主に2種類ある
  1. git initコマンドで初期化する方法
  2. git cloneコマンドでGitHubから入手する方法
- 本章では1.について解説する（次章からは2.で行う）

*** Gitリポジトリの初期化方法
- my_projectディレクトリを作成し，
  Gitリポジトリとして初期化するコマンドは次のとおり
  - 1〜2行目：ディレクトリを作成して移動
  - 3行目：ディレクトリをリポジトリとして初期化

#+begin_src bash
mkdir ~/my_project
cd ~/my_project
git init
#+end_src

- 以降の作業は作成したmy_projectディレクトリで行うこと
  - 現在のディレクトリは「pwd」コマンドで確認できる

*** リポジトリの状態を確認する方法
- 現在のリポジトリの状態を確認するコマンドは次のとおり

#+begin_src bash
git status 
#+end_src

- このコマンドは頻繁に使用する
- 何かうまく行かないことがあったら，このコマンドで状態を確認する癖を
  つけるとよい
  - 表示される内容の意味は徐々に覚えていけば良い

*** 「.git」ディレクトリを壊すべからず
- ティレクトリにリポジトリを作成すると「.git」という隠しディレクトリが
  できる
  - ls -aで確認できるが・・・
- このディレクトリは絶対に， _手動で変更してはならない_
  - むろん，削除もしてはならない

** コミットの作成方法
*** コミットについて
- Gitの用語における「コミット」とは，「ひとかたまりの作業」をいう
  - 新しい機能を追加した，バグを直した，ドキュメントの内容を更新した，など
- Gitは作業の履歴を，コミットを単位として管理する
  - コミットは次々にリポジトリに追加されていき，これらを記録することで
    バーションの管理ができる（古いバージョンに戻る，など）
- コミットには，作業の内容を説明するメッセージをつける
  - 更に，コミットには自動的にIDが振られることも覚えておくと良い

*** READMEファイルの作成
- my_projectリポジトリにREADMEファイルを作成してみよう

#+BEGIN_SRC bash
echo "My README file." > README
#+END_SRC

- プロジェクトには _必ずREADMEファイルを用意_ しておくこと

*** リポジトリの状態の確認
- git statusで現在のリポジトリの状態を確認する

#+BEGIN_SRC bash
git status
#+END_SRC

- 未追跡のファイル（Untracked files:）の欄に作成したREADMEファイルが
  （赤色で）表示される

*** 変更内容のステージング
- コミットの一つ手前にステージングという段階がある
  - 変更をコミットするためには，ステージングしなくてはならない
  - 新しいファイルをステージングすると，これ以降，
    gitがそのファイルの変更を追跡する

*** ステージングの実行
- 作成したREADMEファイルをステージングするには，次のコマンドを打つ

#+BEGIN_SRC bash
git add .
#+END_SRC

- 「git add」の「.（ピリオド）」を忘れないように
  - ピリオドは，リポジトリにおけるすべての変更を意味する
  - 複数のファイルを変更した場合には，ファイル名を指定して
    部分的にステージングすることもできる・・・
    - が，このやりかたは好ましくない
    - 一度に複数の変更を行うのではなく，一つの変更を終えたら
      こまめにコミットする
      
*** ステージング後のリポジトリへの状態
- 再度，git statusコマンドで状態を確認しよう

#+BEGIN_SRC bash
git status
#+END_SRC

- コミットされる変更（Changes to be committed:）の欄に，READMEファイルが
  （緑色で）表示されれば正しい結果である

*** ステージングされた内容をコミットする
- ステージング段階にある変更内容をコミットする
- コミットにはその内容を示すメッセージ文をつける
- 「First commit」というメッセージをつけて新しいコミットを作成する
  - 「-m」オプションはそれに続く文字列をメッセージとして付与することを
    指示するもの

#+BEGIN_SRC bash
git commit -m 'First commit'
#+END_SRC

*** コミット後の状態の確認
- コミットが正常に行われたことを確認する
  - ここでもgit statusコマンドか活躍する

#+BEGIN_SRC bash
git status
#+END_SRC

- 「nothing to commit, ...」との表示から
  コミットすべきものがない（＝過去の変更はコミットされた）ことが
  わかる
- この表示がでたら（無事コミットできたので）一安心してよい

** 変更履歴の作成
*** 更なるコミットを作成する
- リポジトリで変更作業を行い，新しいコミットを追加する
  - READMEファイルに新しい行を追加する
- 次の$NAMEをあなたの名前に変更して実行しなさい

#+BEGIN_SRC bash
echo $NAME >> README
#+END_SRC

- 既存のファイルへの追加なので「>>」を用いていることに注意

*** 変更後の状態の確認
- リポジトリの状態をここでも確認する

#+BEGIN_SRC bash
git status
#+END_SRC

- コミットのためにステージされていない変更（Changes not staged for commit:）の
  欄に，変更された（modified）ファイルとしてREADMEが表示される

*** 差分の確認
- トラックされているファイルの変更箇所を確認する

#+BEGIN_SRC bash
git diff
#+END_SRC

- 頭に「+」のある（緑色で表示された）行が新たに追加された内容を示す
  - 削除した場合は「-」がつく

*** 新たな差分をステージングする
- 作成した差分をコミットできるようにするために，ステージング段階に上げる

#+BEGIN_SRC bash
git add .
#+END_SRC

- git statusを行い，READMEファイルが「Changed to be commited:」の欄に
  （緑色で）表示されていることを確認する
- ステージさせるとgit diffの結果が空になる
  - この場合，「git diff --staged」で確認可能

*** ステージングされた新しい差分のコミット
- 変更内容を示すメッセージとともにコミットする

#+BEGIN_SRC bash
git commit -m 'Add my name'
#+END_SRC

** 履歴の確認
*** バージョン履歴の確認
- これまでの変更作業の履歴を確認
  - 2つのコミットが存在する

#+BEGIN_SRC bash
git log
#+END_SRC

- 各コミットごとに表示される内容
  - コミットのID（commit に続く英文字と数字の列）
  - AuthorとDate
  - コミットメッセージ

*** 一つのファイルの履歴
- 将来，複数のファイルを履歴管理するようになったら特定のファイルの
  履歴のみ確認したい
- その場合，次のとおりにする

#+BEGIN_SRC bash
git log --follow README
#+END_SRC

*** 2つのコミットの比較
- 異なる２つのコミットの変更差分は次のコマンドで確認できる
  - コミットのIDはlogで確認できる（概ね先頭4文字でよい）
  - ブランチごとの比較もできる（後述）

#+BEGIN_SRC bash
git diff $COMMIT_ID_1 $COMMIT_ID_2 
#+END_SRC

*** コミットの情報確認
- 次のコマンドでコミットで行った変更内容が確認できる

#+BEGIN_SRC bash
git show $COMMIT_ID
#+END_SRC


** ブランチの使い方
*** ブランチとは
- 「ひとまとまりの作業」を行う場所
- ソースコードなどの編集作業を始める際には
  必ず新しいブランチを作成する

*** masterは大事なブランチ
- Gitリポジトリの初期化後，最初のコミットを行うとmasterブランチができる
- 非常に重要なブランチであり，
  ここで _直接編集作業を行ってはならない_
  - ただし，本演習や，個人でGitを利用する場合はこの限りではない

*** ブランチの作成
- 新しいブランチ「new_branch」を作成して，なおかつ，そのブランチに移動する
  - 「-b」オプションで新規作成
  - オプションがなければ単なる移動（後述）

#+BEGIN_SRC bash
git checkout -b new_branch
#+END_SRC

- 本来，ブランチには「これから行う作業の内容」が分かるような名前を付ける

*** ブランチの確認
- ブランチの一覧と現在のブランチを確認する
  - もともとあるmasterと，新しく作成したnew_branchが表示される
  - 

#+BEGIN_SRC bash
git branch -vv
#+END_SRC

*** ブランチの移動

- ブランチ「new_branch」に移動する

#+BEGIN_SRC bash
git checkout new_branch
#+END_SRC

- git branch -vvで現在のブランチを確認してみよう
- git statusの一行目にも現在のブランチが表示される

*** ブランチの削除

- 作成したブランチを削除する
  - 1行目：一度masterブランチに移動する

#+BEGIN_SRC bash
git checkout master
git branch -d new_branch
git branch -vv
#+END_SRC


** その他のコマンド
*** ステージング/コミットの修正
ファイルのステージングを取り消す

#+BEGIN_SRC bash
git reset $FILE
#+END_SRC

$COMMITより後のコミットの取り消し（ローカルは保存）

#+BEGIN_SRC bash
git reset $COMMIT
#+END_SRC

$COMMITより後のコミットの取り消し（ローカルの変更も破棄）

#+BEGIN_SRC bash
git reset --hard $COMMIT
#+END_SRC

* 未整理
** Gitリポジトリ
*** 基本的な git コマンド
新しくブランチを作成してチェックアウトする

#+begin_src bash
git checkout -b some_new_feature
#+end_src

ブランチをGitHubにpushする

#+begin_src bash
git add .
git commit -m '（作業内容）'
git push -u origin some_new_feature
#+end_src


** GitHubとは
*** TODO Gitとは
*** GitHubについて
    - ソーシャルコーディングのためのクラウド環境
      - [[https://github.com/][GitHub]]
      - [[http://github.co.jp/][GitHub Japan]]
    - GitHubが提供する主な機能
      - GitHub flowによる協同開発
      - Pull requests
      - Issue / Wiki
      - コード解析

*** GitHub Flow
    - Git-flow
      - GitHub が登場する以前、 Git-flow が提唱された
      - [[http://nvie.com/posts/a-successful-git-branching-model/][A successful Git branching model » nvie.com]]
    - GitHub flow
      - GitHub により、よりシンプルで強力なワークフローが可能に
      - [[http://scottchacon.com/2011/08/31/github-flow.html][GitHub Flow – Scott Chacon]]
      - [[https://gist.github.com/Gab-km/3705015][GitHub Flow (Japanese translation)]]

*** TODO [後ろへ] GitHub flow におけるコンフリクトについて
    - マージのコンフリクト
      - GitHub に提出した Pull requests が自動的にマージできないこと
    - 基本的な対処法
      - コンフリクトは、コードの同じ箇所を複数の人が別々に編集すると発生
      - 初心者は、演習の最初の方では「他人と同じファイルを編集しない」こと
	にして、操作になれる
      - 上達したら積極的にコンフリクトを起こしてみて、その解決方法を学ぶ
      - Pull requests でコンフリクトが発生し、自動的にマージできない状態に
	なったら、 その PR を送った人がコンフリクトを自分で解消する
*** コラボレーターの追加

- GitHubのリポジトリをブラウザで開く．
- Settings -> Collaborators を選ぶ
- メンバーを招待する
- 招待されたメンバーには確認のメールが届くので，リンクをクリックする

*** コラボレーターがソースコードを入手する方法

下記の「ychubachi」の部分を代表者のアカウント名にする．
#+begin_src bash
git clone ychubachi/ychubachi_2016_gem
#+end_src

**** プルリクエストとマージ

- ブランチがGitHubに登録されたことを確認し，Pull requestを作成する
- Pull requestのレビューが済んだらマージする

**** ローカルのmaster を最新版にする

- GitHubで行ったマージをローカルに反映させる

#+begin_src bash
git checkout master
git pull
#+end_src

*** GitHubでのコンフリクトの解消方法
**** 前提
     - new_feature ブランチで作業中であり、最新の更新は commit 済

**** 操作（一例）

#+begin_src bash
git checkout master         # master をチェックアウト
git pull origin master      # 手元の master を最新版にする
git checkout new_feature    # 作業中のブランチに戻る
git merge master            # この後、コンフリクトを修正する
git push origin new_feature # 作業中のブランチを再度、push
#+end_src


*** Gemの作成からGitHubへの登録まで

#+begin_src bash
bundle gem ychubachi_2016_gem
cd ychubachi_2016_gem/
git commit -m 'Initial commit'
git create
git push -u origin master
#+end_src

* 演習
** ペアで行う GitHub
*** ペアで GitHub を使ってみよう
    1. 隣同士でペアを組む
    2. レポジトリを作成する（どちらか一方）
       - =bundle gem= でひな形を作る（初心者は Gem でなくても良い）
    3. レポジトリの Collaborators に登録する
    4. レポジトリに対して、次のことを行う
       - Pull requests を利用してみる
       - Issue を利用してみる
       - Wiki を利用してみる
*** 課題1
    1. Pull request & merge の作業を各自5回以上行う
       - ディスカッションやコードレビューもやってみる
    2. Issue を5個以上登録する
       - Pull request による Issue の close なども試す
    3. Wiki でページを作成する
       - ページを5つ程度作成して、リンクも貼る
    4. 以上が終わったペアはグループでの演習に進む
       - 講師に申告すること
	 
** グループで行う GitHub
*** 課題：グループで GitHub (1)
    1. ペアを2つ組み合わせて4人グループを作成する
       - 課題1が終わったペアから順番にグループ編成
    2. 作りたい Gem について相談して仕様を決める
       - テーマはなんでも良い
         - Web API を利用したコマンドラインツールなど
       - ある程度の役割分担も決めておく
    3. レポジトリを作成する（代表者1名）
       - コラボレーターを追加する
    4. 今まで学んだ知識を活用して Gem を開発する
*** 課題：グループで GitHub (2)
    1. グルーブメンバーでGemを共同で作成する
    2. GitHub Flow の実践
    3. Travis CI によるテストの自動化
    4. RubyGems.org への自動ディプロイ
    5. その他、GitHub の各種機能の活用

* Git解説
** 解説
- gitにはブランチ（branch）の概念がある
- 最初にあるのはmasterブランチ
- masterは一番大切なブランチであり，常に正常に動作する状態にする
- 新しい作業を開始するときは必ず新しいbranchを作る
- 後に，作業内容をmasterに取り込む（merge）
* Git演習
** ブランチの作成
*** 課題

「new_feature」ブランチを作成せよ

#+begin_src bash
git checkout -b new_feature
#+end_src

*** 確認
- 方法1) git status の結果の一行目が「On brunch new_feature」になっていること
- 方法2) git status の一行目が「On brunch new_feature」になっていること


* GitHub演習（個人）
** アカウントの作成
*** 課題
[[https://github.com/][GitHub]] にアカウントを作成せよ
*** 提出
TODO: Google form


